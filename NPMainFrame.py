# -*- coding: UTF-8 -*-
#
# generated by wxGlade 0.6.8 on Sat Oct 12 14:20:36 2013
#

from NPDataFrame import NPDataFrame
from collections import deque
from datetime import datetime
from DynLightPlotFrame import DynLightPlotFrame
import os
import serial
from serial.tools import list_ports
import sys
import threading
import wx
import ConfigParser
import time
# begin wxGlade: dependencies
from npControlNotebook import npControlNotebook
# end wxGlade

# begin wxGlade: extracode
# end wxGlade

#----------------------------------------------------------------------
# Create an own event type, so that GUI updates can be delegated
# this is required as on some platforms only the main thread can
# access the GUI without crashing. wxMutexGuiEnter/wxMutexGuiLeave
# could be used too, but an event is more elegant.

# TODO: deal with different channels in dynamic light program properly

SERIALRX        = wx.NewEventType()
# bind to serial data receive events
EVT_SERIALRX    = wx.PyEventBinder(SERIALRX, 0)

#----------------------------------------------------------------------
ID_SETTINGS     = wx.NewId()
ID_EXIT         = wx.NewId()


config  = ConfigParser.RawConfigParser()
config.read('./pyNPConfig.cfg')
# read logging section
msgSep  = config.get('logging', 'msgSep')
msgTerm = config.get('logging', 'msgTerm')
DEBUG   = config.getboolean('logging', 'DEBUG')
# names of values obtained from the reactor
CHANNEL_NAMES   = config.get('logging', 'CHANNEL_NAMES').split(',')
# read plot section
# max. number of samples to show in plot
BUFFER_SIZE     = config.getint('plotting', 'BUFFER_SIZE')
# read dynamicLight section
# number of Brightness/duration tuples stored in the reactor as dynamic light program
maxDynLightLen  = config.getint('dynamicLight', 'maxDynLightLen')


class NPMainFrame(wx.Frame):
    def __init__(self, *args, **kwds):
        
        self.serial         = serial.Serial()
        self.serial.timeout = 0.5   #make sure that the alive event can be checked from time to time
        self.thread         = None
        self.alive          = threading.Event()
        self.dataFrame      = NPDataFrame(None, wx.ID_ANY, "")
        self.dataFrame.mainFrame = self
        self.dataFrame.Show()
        # reactor data
        self.logging_active = False
        self.numChambers    = 0
        self.numLeds        = 0
        self.referenceVals1 = [0]  # reference values from detector 1
        self.odVals1        = [0] # od values from detector 1
        self.bgVals         = 0 # background values for both detectors
        self.temp           = 0 # sample temperature
        self.lightBrightness = [0]
        self.reactorMode    = 1
        self.minLight       = 0
        self.maxLight       = 255
        self.sampleRate     = 10
        self.sampleTime     = 0
        self.reference_values_measured  = False
        # dynamic light program definition
        self.dynLight = [[(0,0)]*maxDynLightLen, [(0,0)]*maxDynLightLen, [(0,0)]*maxDynLightLen]
        # frame showing a plot of the profile
        self.dynLightPlotFrame = None
        # frame showing real time plot of OD curve
        self.odCurveFrame = None
        self.dataStore    = None
        # background colors representing the operation modes
        # mode order: standby, light, dark, dynamic, error
        self.mode_bg_cols    =   [(12, 123, 232), (232, 222, 44), (0, 0, 255), (177, 232, 0 ), (255, 0, 0)]
        
        # begin wxGlade: NPMainFrame.__init__
        kwds["style"] = wx.DEFAULT_FRAME_STYLE
        wx.Frame.__init__(self, *args, **kwds)
        self.notebook_main = wx.Notebook(self, wx.ID_ANY)
        self.notebook_1_pane_1 = npControlNotebook(self.notebook_main, wx.ID_ANY)
        self.notebook_reactor_connection = wx.Panel(self.notebook_main, wx.ID_ANY)
        self.label_1_copy = wx.StaticText(self.notebook_reactor_connection, wx.ID_ANY, _("NinjaPBR Control"))
        self.label_9 = wx.StaticText(self.notebook_reactor_connection, wx.ID_ANY, _("Reactor Connection Configuration"))
        self.label_10 = wx.StaticText(self.notebook_reactor_connection, wx.ID_ANY, _("Select Connection"))
        self.serial_connection_combo_box = wx.ComboBox(self.notebook_reactor_connection, wx.ID_ANY, choices=[], style=wx.CB_DROPDOWN)
        self.button_connect_serial = wx.Button(self.notebook_reactor_connection, wx.ID_ANY, _("Connect"))
        self.button_refresh_serial_copy = wx.Button(self.notebook_reactor_connection, wx.ID_ANY, _("Refresh"))
        self.notebook_logging = wx.Panel(self.notebook_main, wx.ID_ANY)
        self.label_1_copy_copy = wx.StaticText(self.notebook_logging, wx.ID_ANY, _("NinjaPBR Control"))
        self.label_11 = wx.StaticText(self.notebook_logging, wx.ID_ANY, _("Data Logging Configuration"))
        self.button_select_logfile = wx.Button(self.notebook_logging, wx.ID_ANY, _("Select Logfile"))
        self.label_active_log_file = wx.StaticText(self.notebook_logging, wx.ID_ANY, _("./log.txt"))
        self.logging_active_button = wx.ToggleButton(self.notebook_logging, wx.ID_ANY, _("Activate Logging"))
        self.button_download_reactor_log = wx.Button(self.notebook_logging, wx.ID_ANY, _("Download Data into Logfile"))
        self.notebook_reference_values = wx.Panel(self.notebook_main, wx.ID_ANY)
        self.label_1_copy_copy_copy = wx.StaticText(self.notebook_reference_values, wx.ID_ANY, _("NinjaPBR Control"))
        self.label_12 = wx.StaticText(self.notebook_reference_values, wx.ID_ANY, _("Reference Value Measurement"))
        self.button_measure_refs = wx.Button(self.notebook_reference_values, wx.ID_ANY, _("Measure Reference Vals"))
        self.label_led1_ch1 = wx.StaticText(self.notebook_reference_values, wx.ID_ANY, _("Led1 (Ch1)"))
        self.label_led1_1 = wx.StaticText(self.notebook_reference_values, wx.ID_ANY, _("-"))
        self.label_led1_ch2 = wx.StaticText(self.notebook_reference_values, wx.ID_ANY, _("Led1 (Ch2)"))
        self.label_led1_2 = wx.StaticText(self.notebook_reference_values, wx.ID_ANY, _("-"))
        self.label_led1_ch3 = wx.StaticText(self.notebook_reference_values, wx.ID_ANY, _("Led3 (Ch3)"))
        self.label_led1_3 = wx.StaticText(self.notebook_reference_values, wx.ID_ANY, _("-"))
        self.label_led2_ch1 = wx.StaticText(self.notebook_reference_values, wx.ID_ANY, _("Led2 (Ch1)"))
        self.label_led2_1 = wx.StaticText(self.notebook_reference_values, wx.ID_ANY, _("-"))
        self.label_led2_ch2 = wx.StaticText(self.notebook_reference_values, wx.ID_ANY, _("Led2 (Ch2)"))
        self.label_led2_2 = wx.StaticText(self.notebook_reference_values, wx.ID_ANY, _("-"))
        self.label_led2_ch3 = wx.StaticText(self.notebook_reference_values, wx.ID_ANY, _("Led2 (Ch3)"))
        self.label_led2_3 = wx.StaticText(self.notebook_reference_values, wx.ID_ANY, _("-"))
        self.label_led3_ch1 = wx.StaticText(self.notebook_reference_values, wx.ID_ANY, _("Led3 (Ch1)"))
        self.label_led3_1 = wx.StaticText(self.notebook_reference_values, wx.ID_ANY, _("-"))
        self.label_led3_ch2 = wx.StaticText(self.notebook_reference_values, wx.ID_ANY, _("Led3 (Ch2)"))
        self.label_led3_2 = wx.StaticText(self.notebook_reference_values, wx.ID_ANY, _("-"))
        self.label_led3_ch3 = wx.StaticText(self.notebook_reference_values, wx.ID_ANY, _("Led3 (Ch3)"))
        self.label_led3_3 = wx.StaticText(self.notebook_reference_values, wx.ID_ANY, _("-"))
        self.label_led4_ch1 = wx.StaticText(self.notebook_reference_values, wx.ID_ANY, _("Led4 (Ch1)"))
        self.label_led4_1 = wx.StaticText(self.notebook_reference_values, wx.ID_ANY, _("-"))
        self.label_led4_ch2 = wx.StaticText(self.notebook_reference_values, wx.ID_ANY, _("Led4 (Ch2)"))
        self.label_led4_2 = wx.StaticText(self.notebook_reference_values, wx.ID_ANY, _("-"))
        self.label_led4_ch3 = wx.StaticText(self.notebook_reference_values, wx.ID_ANY, _("Led4 (Ch3)"))
        self.label_led4_3 = wx.StaticText(self.notebook_reference_values, wx.ID_ANY, _("-"))
        self.label_led5_ch1 = wx.StaticText(self.notebook_reference_values, wx.ID_ANY, _("Led5 (Ch1)"))
        self.label_led5_1 = wx.StaticText(self.notebook_reference_values, wx.ID_ANY, _("-"))
        self.label_led5_ch2 = wx.StaticText(self.notebook_reference_values, wx.ID_ANY, _("Led5 (Ch2)"))
        self.label_led5_2 = wx.StaticText(self.notebook_reference_values, wx.ID_ANY, _("-"))
        self.label_led5_ch3 = wx.StaticText(self.notebook_reference_values, wx.ID_ANY, _("Led5 (Ch3)"))
        self.label_led5_3 = wx.StaticText(self.notebook_reference_values, wx.ID_ANY, _("-"))
        self.notebook_dyn_light = wx.Panel(self.notebook_main, wx.ID_ANY)
        self.label_dynLightTitle = wx.StaticText(self.notebook_dyn_light, wx.ID_ANY, _("NinjaPBR Control"))
        self.label_14 = wx.StaticText(self.notebook_dyn_light, wx.ID_ANY, _("Dynamic Light Program"))
        self.label_5_copy = wx.StaticText(self.notebook_dyn_light, wx.ID_ANY, _("Selected Chamber:"))
        self.button_ld_dynlght_copy_copy_copy = wx.Button(self.notebook_dyn_light, wx.ID_ANY, _("Load File"))
        self.button_uld_dynlght_copy_copy = wx.Button(self.notebook_dyn_light, wx.ID_ANY, _("Upload to Reactor"))
        self.dyn_light_ch_select_combo_box = wx.ComboBox(self.notebook_dyn_light, wx.ID_ANY, choices=[_("0"), _("1"), _("2")], style=wx.CB_DROPDOWN)
        self.button_plotDynLight_copy_copy_copy = wx.Button(self.notebook_dyn_light, wx.ID_ANY, _("Show Profile"))
        self.button_dld_dynlght_copy_copy_copy = wx.Button(self.notebook_dyn_light, wx.ID_ANY, _("Download From Reactor"))
        self.label_5_copy_1_copy = wx.StaticText(self.notebook_dyn_light, wx.ID_ANY, _("File Loaded:"))
        self.dyn_light_filepath_label = wx.StaticText(self.notebook_dyn_light, wx.ID_ANY, _("-"))
        self.label_5_copy_1 = wx.StaticText(self.notebook_dyn_light, wx.ID_ANY, "")
        self.unused = wx.StaticText(self.notebook_dyn_light, wx.ID_ANY, "")

        self.__set_properties()
        self.__do_layout()

        self.Bind(wx.EVT_BUTTON, self.OnOpenConnectReactorButton, self.button_connect_serial)
        self.Bind(wx.EVT_BUTTON, self.OnOpenRefreshReactorListButton, self.button_refresh_serial_copy)
        self.Bind(wx.EVT_BUTTON, self.OnOpenLogfileDialogButton, self.button_select_logfile)
        self.Bind(wx.EVT_TOGGLEBUTTON, self.OnActivateLoggingButtonClicked, self.logging_active_button)
        self.Bind(wx.EVT_BUTTON, self.OnDownloadReactorLogButton, self.button_download_reactor_log)
        self.Bind(wx.EVT_BUTTON, self.OnOpenMeasureRefValsButton, self.button_measure_refs)
        self.Bind(wx.EVT_BUTTON, self.OnOpenDynLightFileDialogButton, self.button_ld_dynlght_copy_copy_copy)
        self.Bind(wx.EVT_BUTTON, self.OnOpenUploadDynLightButton, self.button_uld_dynlght_copy_copy)
        self.Bind(wx.EVT_BUTTON, self.OnShowDynLightClicked, self.button_plotDynLight_copy_copy_copy)
        self.Bind(wx.EVT_BUTTON, self.OnOpenDownloadDynLightButton, self.button_dld_dynlght_copy_copy_copy)
        # end wxGlade
        self.__attach_events()          # register events
        self.list_connections()         # fill list with all serial connections
        self.serial_connection_combo_box.SetSelection(self.serial_connection_combo_box.GetCount()-1)# select last connection by default
        
        self.dyn_light_ch_select_combo_box.SetSelection(0)
        # make list of GUI labels
        self.reference_val_labels      = [[],[],[]]
        self.reference_val_labels[0] = [self.label_led1_ch1, self.label_led2_ch1, self.label_led3_ch1, self.label_led4_ch1, self.label_led5_ch1]
        self.reference_val_labels[1] = [self.label_led1_ch2, self.label_led2_ch2, self.label_led3_ch2, self.label_led4_ch2, self.label_led5_ch2]
        self.reference_val_labels[2] = [self.label_led1_ch3, self.label_led2_ch3, self.label_led3_ch3, self.label_led4_ch3, self.label_led5_ch3]
        self.reference_val_data_labels    = [[],[],[]]
        self.reference_val_data_labels[0] = [self.label_led1_1, self.label_led2_1, self.label_led3_1, self.label_led4_1, self.label_led5_1]
        self.reference_val_data_labels[1] = [self.label_led1_2, self.label_led2_2, self.label_led3_2, self.label_led4_2, self.label_led5_2]
        self.reference_val_data_labels[2] = [self.label_led1_3, self.label_led2_3, self.label_led3_3, self.label_led4_3, self.label_led5_3]
        self.od_val_data_labels     = [self.dataFrame.OD_value_led1_label, self.dataFrame.OD_value_led2_label, self.dataFrame.OD_value_led3_label, self.dataFrame.OD_value_led4_label, self.dataFrame.OD_value_led5_label]
        self.od_data_labels         = [self.dataFrame.OD_led1_label, self.dataFrame.OD_led2_label, self.dataFrame.OD_led3_label, self.dataFrame.OD_led4_label, self.dataFrame.OD_led5_label]


    def __set_properties(self):
        # begin wxGlade: NPMainFrame.__set_properties
        self.SetTitle(_("NonjaPBR Control"))
        self.SetSize((730, 320))
        self.label_1_copy.SetFont(wx.Font(40, wx.DEFAULT, wx.NORMAL, wx.NORMAL, 0, "Lucida Grande"))
        self.label_9.SetFont(wx.Font(20, wx.DEFAULT, wx.NORMAL, wx.NORMAL, 0, "Lucida Grande"))
        self.serial_connection_combo_box.SetMinSize((250, -1))
        self.serial_connection_combo_box.SetToolTipString(_("Select serial connection of the reactor"))
        self.button_connect_serial.SetMinSize((94, 20))
        self.button_connect_serial.SetToolTipString(_("Establish connection to Reactor"))
        self.button_refresh_serial_copy.SetToolTipString(_("Refresh list of available serial connections "))
        self.label_1_copy_copy.SetFont(wx.Font(40, wx.DEFAULT, wx.NORMAL, wx.NORMAL, 0, "Lucida Grande"))
        self.label_11.SetFont(wx.Font(20, wx.DEFAULT, wx.NORMAL, wx.NORMAL, 0, "Lucida Grande"))
        self.button_select_logfile.SetToolTipString(_("File which stores data permanently"))
        self.logging_active_button.SetToolTipString(_("Activate to start writing data to Log File"))
        self.button_download_reactor_log.SetToolTipString(_("File which stores data permanently"))
        self.label_1_copy_copy_copy.SetFont(wx.Font(40, wx.DEFAULT, wx.NORMAL, wx.NORMAL, 0, "Lucida Grande"))
        self.button_measure_refs.SetMinSize((200, 20))
        self.button_measure_refs.SetToolTipString(_("Reference OD of culture chamber and medium only"))
        self.label_dynLightTitle.SetFont(wx.Font(40, wx.DEFAULT, wx.NORMAL, wx.NORMAL, 0, "Lucida Grande"))
        self.label_14.SetFont(wx.Font(20, wx.DEFAULT, wx.NORMAL, wx.NORMAL, 0, "Lucida Grande"))
        self.button_ld_dynlght_copy_copy_copy.SetToolTipString(_("Text file holding the light/duration tuples"))
        self.button_uld_dynlght_copy_copy.SetToolTipString(_("transfer loaded program to reactor"))
        self.dyn_light_ch_select_combo_box.SetMinSize((250, -1))
        self.dyn_light_ch_select_combo_box.SetToolTipString(_("Select reactor chamber to set dynamic light"))
        self.dyn_light_ch_select_combo_box.SetFocus()
        self.dyn_light_ch_select_combo_box.SetSelection(-1)
        self.button_plotDynLight_copy_copy_copy.SetToolTipString(_("display plot of loaded program"))
        self.button_dld_dynlght_copy_copy_copy.SetToolTipString(_("retrieve program curretly on the reactor"))
        self.dyn_light_filepath_label.SetMinSize((250, -1))
        self.unused.SetMinSize((250, -1))
        # end wxGlade

    def __do_layout(self):
        # begin wxGlade: NPMainFrame.__do_layout
        sizer_main = wx.BoxSizer(wx.VERTICAL)
        sizer_dyn_light_main = wx.BoxSizer(wx.VERTICAL)
        sizer_22 = wx.BoxSizer(wx.VERTICAL)
        sizer_5_copy = wx.BoxSizer(wx.HORIZONTAL)
        sizer_6 = wx.BoxSizer(wx.HORIZONTAL)
        grid_sizer_4_copy = wx.GridSizer(3, 3, 0, 0)
        sizer_refVals_main = wx.BoxSizer(wx.VERTICAL)
        sizer_21 = wx.BoxSizer(wx.VERTICAL)
        grid_sizer_2 = wx.GridSizer(5, 6, 0, 0)
        sizer_logging_main = wx.BoxSizer(wx.VERTICAL)
        sizer_19 = wx.BoxSizer(wx.VERTICAL)
        sizer_20 = wx.BoxSizer(wx.VERTICAL)
        sizer_connection_main = wx.BoxSizer(wx.VERTICAL)
        sizer_15 = wx.BoxSizer(wx.VERTICAL)
        sizer_16 = wx.BoxSizer(wx.HORIZONTAL)
        sizer_18 = wx.BoxSizer(wx.VERTICAL)
        sizer_17 = wx.BoxSizer(wx.VERTICAL)
        sizer_connection_main.Add(self.label_1_copy, 0, wx.ALIGN_CENTER_HORIZONTAL, 0)
        sizer_15.Add(self.label_9, 0, wx.ALIGN_CENTER_HORIZONTAL, 0)
        sizer_17.Add(self.label_10, 0, wx.ALIGN_CENTER, 0)
        sizer_17.Add(self.serial_connection_combo_box, 0, wx.ALIGN_CENTER, 0)
        sizer_16.Add(sizer_17, 1, 0, 0)
        sizer_18.Add(self.button_connect_serial, 0, wx.ALIGN_CENTER_VERTICAL | wx.ALL, 10)
        sizer_18.Add(self.button_refresh_serial_copy, 0, wx.ALIGN_CENTER_VERTICAL | wx.ALL, 10)
        sizer_16.Add(sizer_18, 1, wx.EXPAND, 0)
        sizer_15.Add(sizer_16, 1, wx.EXPAND, 0)
        sizer_connection_main.Add(sizer_15, 1, wx.EXPAND, 0)
        self.notebook_reactor_connection.SetSizer(sizer_connection_main)
        sizer_logging_main.Add(self.label_1_copy_copy, 0, wx.ALIGN_CENTER_HORIZONTAL, 0)
        sizer_19.Add(self.label_11, 0, wx.ALIGN_CENTER_HORIZONTAL, 0)
        sizer_20.Add(self.button_select_logfile, 0, wx.ALIGN_CENTER | wx.ALL, 10)
        sizer_20.Add(self.label_active_log_file, 0, wx.ALIGN_CENTER | wx.ALL, 10)
        sizer_20.Add(self.logging_active_button, 0, wx.ALIGN_CENTER, 0)
        sizer_20.Add(self.button_download_reactor_log, 0, wx.ALIGN_CENTER | wx.ALL, 10)
        sizer_19.Add(sizer_20, 1, wx.EXPAND, 0)
        sizer_logging_main.Add(sizer_19, 1, wx.EXPAND, 0)
        self.notebook_logging.SetSizer(sizer_logging_main)
        sizer_refVals_main.Add(self.label_1_copy_copy_copy, 0, wx.ALIGN_CENTER_HORIZONTAL, 0)
        sizer_21.Add(self.label_12, 0, wx.ALIGN_CENTER_HORIZONTAL | wx.ALL, 10)
        sizer_21.Add(self.button_measure_refs, 0, wx.ALIGN_CENTER | wx.ALL, 10)
        grid_sizer_2.Add(self.label_led1_ch1, 0, wx.ALL, 10)
        grid_sizer_2.Add(self.label_led1_1, 0, wx.ALL, 10)
        grid_sizer_2.Add(self.label_led1_ch2, 0, wx.ALL, 10)
        grid_sizer_2.Add(self.label_led1_2, 0, wx.ALL, 10)
        grid_sizer_2.Add(self.label_led1_ch3, 0, wx.ALL, 10)
        grid_sizer_2.Add(self.label_led1_3, 0, wx.ALL, 10)
        grid_sizer_2.Add(self.label_led2_ch1, 0, wx.ALL, 10)
        grid_sizer_2.Add(self.label_led2_1, 0, wx.ALL, 10)
        grid_sizer_2.Add(self.label_led2_ch2, 0, wx.ALL, 10)
        grid_sizer_2.Add(self.label_led2_2, 0, wx.ALL, 10)
        grid_sizer_2.Add(self.label_led2_ch3, 0, wx.ALL, 10)
        grid_sizer_2.Add(self.label_led2_3, 0, wx.ALL, 10)
        grid_sizer_2.Add(self.label_led3_ch1, 0, wx.ALL, 10)
        grid_sizer_2.Add(self.label_led3_1, 0, wx.ALL, 10)
        grid_sizer_2.Add(self.label_led3_ch2, 0, wx.ALL, 10)
        grid_sizer_2.Add(self.label_led3_2, 0, wx.ALL, 10)
        grid_sizer_2.Add(self.label_led3_ch3, 0, wx.ALL, 10)
        grid_sizer_2.Add(self.label_led3_3, 0, wx.ALL, 10)
        grid_sizer_2.Add(self.label_led4_ch1, 0, wx.ALL, 10)
        grid_sizer_2.Add(self.label_led4_1, 0, wx.ALL, 10)
        grid_sizer_2.Add(self.label_led4_ch2, 0, wx.ALL, 10)
        grid_sizer_2.Add(self.label_led4_2, 0, wx.ALL, 10)
        grid_sizer_2.Add(self.label_led4_ch3, 0, wx.ALL, 10)
        grid_sizer_2.Add(self.label_led4_3, 0, wx.ALL, 10)
        grid_sizer_2.Add(self.label_led5_ch1, 0, wx.ALL, 10)
        grid_sizer_2.Add(self.label_led5_1, 0, wx.ALL, 10)
        grid_sizer_2.Add(self.label_led5_ch2, 0, wx.ALL, 10)
        grid_sizer_2.Add(self.label_led5_2, 0, wx.ALL, 10)
        grid_sizer_2.Add(self.label_led5_ch3, 0, wx.ALL, 10)
        grid_sizer_2.Add(self.label_led5_3, 0, wx.ALL, 10)
        sizer_21.Add(grid_sizer_2, 1, wx.ALIGN_CENTER_HORIZONTAL, 0)
        sizer_refVals_main.Add(sizer_21, 1, wx.EXPAND, 0)
        self.notebook_reference_values.SetSizer(sizer_refVals_main)
        sizer_dyn_light_main.Add(self.label_dynLightTitle, 0, wx.ALIGN_CENTER_HORIZONTAL, 0)
        sizer_22.Add(self.label_14, 0, wx.ALIGN_CENTER_HORIZONTAL, 0)
        grid_sizer_4_copy.Add(self.label_5_copy, 0, wx.ALL, 10)
        grid_sizer_4_copy.Add(self.button_ld_dynlght_copy_copy_copy, 0, wx.ALIGN_CENTER | wx.ALL, 10)
        grid_sizer_4_copy.Add(self.button_uld_dynlght_copy_copy, 0, wx.ALIGN_CENTER | wx.ALL, 10)
        grid_sizer_4_copy.Add(self.dyn_light_ch_select_combo_box, 0, wx.ALL, 0)
        grid_sizer_4_copy.Add(self.button_plotDynLight_copy_copy_copy, 0, wx.ALIGN_CENTER | wx.ALL, 10)
        grid_sizer_4_copy.Add(self.button_dld_dynlght_copy_copy_copy, 0, wx.ALIGN_CENTER | wx.ALL, 10)
        grid_sizer_4_copy.Add(self.label_5_copy_1_copy, 0, 0, 10)
        grid_sizer_4_copy.Add(self.dyn_light_filepath_label, 0, 0, 10)
        sizer_6.Add(grid_sizer_4_copy, 1, 0, 0)
        sizer_22.Add(sizer_6, 1, 0, 0)
        sizer_5_copy.Add(self.label_5_copy_1, 0, wx.ALIGN_BOTTOM | wx.ALL, 10)
        sizer_5_copy.Add(self.unused, 0, wx.ALIGN_BOTTOM | wx.ALL, 10)
        sizer_22.Add(sizer_5_copy, 1, 0, 0)
        sizer_dyn_light_main.Add(sizer_22, 1, wx.ALIGN_CENTER_HORIZONTAL | wx.EXPAND, 0)
        self.notebook_dyn_light.SetSizer(sizer_dyn_light_main)
        self.notebook_main.AddPage(self.notebook_1_pane_1, _("Main"))
        self.notebook_main.AddPage(self.notebook_reactor_connection, _("Reactor Connection"))
        self.notebook_main.AddPage(self.notebook_logging, _("Logging"))
        self.notebook_main.AddPage(self.notebook_reference_values, _("Reference Values"))
        self.notebook_main.AddPage(self.notebook_dyn_light, _("Dynamic Light Mode"))
        sizer_main.Add(self.notebook_main, 1, wx.EXPAND, 0)
        self.SetSizer(sizer_main)
        self.Layout()
        # end wxGlade

    def StartThread(self):
        """Start the receiver thread"""        
        self.thread = threading.Thread(target=self.ComPortThread)
        self.thread.setDaemon(1)
        self.alive.set()
        self.thread.start()

    def StopThread(self):
        """Stop the receiver thread, wait util it's finished."""
        if self.thread is not None:
            self.alive.clear()          #clear alive event for thread
            self.thread.join()          #wait until thread has finished
            self.thread = None
            
    def __attach_events(self):
        #register events at the controls
        self.Bind(wx.EVT_MENU, self.OnExit, id = ID_EXIT)
        self.Bind(EVT_SERIALRX, self.OnSerialRead)
        self.Bind(wx.EVT_CLOSE, self.OnClose)

    def OnExit(self, event):
        """Menu point Exit"""
        self.Close()

    def OnClose(self, event):
        """Called on application shutdown."""
        self.StopThread()               #stop reader thread
        self.serial.close()             #cleanup
        if not self.dataFrame == None:  #close windows, exit app
            self.dataFrame.Destroy()
        if not self.dynLightPlotFrame == None:
            self.dynLightPlotFrame.Destroy()
        if not self.odCurveFrame == None:
            self.odCurveFrame.Destroy()
        self.Destroy()
        sys.exit(0)
        
    def OnSerialRead(self, event):
        """Handle input from the serial port."""
        text = event.data
        dataSections = text.split(";")
        if DEBUG:
                print "received reactor message: " + text
        
        # reference values
        if dataSections[0] == "ERROR": 
            print "Reactor Error occurred: " + dataSections[1]
        elif dataSections[0] == "REF": 
            self.digestReferenceValues(dataSections)
        elif dataSections[0] == "MD": # received updated reactor mode
            self.digestReactorModeValues(dataSections)
        elif dataSections[0] == "DATA": # received sample data
            self.digestSampleValues(dataSections)
        elif dataSections[0] == "LP": # received light profile 
            self.digestLightProfile(dataSections)
        elif dataSections[0] == "HS": # received light profile 
            self.digestHandshake(dataSections)
        else:
            print "Unknown Reactor Message " + dataSections[0] + "!"
            if DEBUG:
                print text
                    
    def ComPortThread(self):
        """Thread that handles the incomming traffic. Reads an entire line
         and generates an SerialRxEvent, which is processed in the main thread
         """
        while self.alive.isSet():               #loop while alive event is true
            text = self.serial.readline()          #read one, with timout
            if text:                            #check if not timeout
                event = SerialRxEvent(self.GetId(), text)
                self.GetEventHandler().AddPendingEvent(event)

    def OnOpenConnectReactorButton(self, event):  # wxGlade: NPMainFrame.<event_handler>
        """(dis)-connect current serial connection, depending on whether a current
        connection exists"""
        if(self.serial.isOpen()):
            if DEBUG:
                print "currently connected to serial: " + self.serial.port + ". Disconnecting... "
            self.sendMessage("bye","")
            self.StopThread()               #stop reader thread
            self.serial.close()             #disconnect serial
            self.button_connect_serial.SetLabel("Connect") # set button to connect
            # set background back to default gray
            self.dataFrame.SetBackgroundColour('LIGHT GREY')
            self.reference_values_measured  = False
            self.resetReactorData()
            return
        else:
            try:
                self.serial.port = self.serial_connection_combo_box.GetValue()
                self.serial.baudrate = 19200
                self.serial.open()
            except serial.SerialException, e:
                dlg = wx.MessageDialog(None, str(e), "Serial Port Error", wx.OK | wx.ICON_ERROR)
                dlg.ShowModal()
                dlg.Destroy()
            else:
                if DEBUG:
                    print "connected to serial: " + self.serial.port
                self.StartThread()
                self.button_connect_serial.SetLabel("Disconnect") # set button to disconnect

    def OnOpenRefreshReactorListButton(self, event):  # wxGlade: NPMainFrame.<event_handler>
        """refresh the list of available serial connections, as shown in the interface"""
        self.list_connections()

    def OnOpenLogfileDialogButton(self, event):  # wxGlade: NPMainFrame.<event_handler>
        """select log file to store data in"""
        dirname = ""
        dlg     = wx.FileDialog(self, "Choose a Log File", dirname, "", "*.*", wx.OPEN)
        f = None
        if dlg.ShowModal() == wx.ID_OK:
            filename    = dlg.GetFilename()
            dirname     = dlg.GetDirectory()
            f           = os.path.join(dirname, filename)
        dlg.Destroy()
        if f:
            self.label_active_log_file.SetLabel(f)
        else:
            self.label_active_log_file.SetLabel("./log.txt")
            
    def OnOpenMeasureRefValsButton(self, event):  # wxGlade: NPMainFrame.<event_handler>
        """send reactor message to aquire reference values"""
        self.sendMessage("mre","")

    def OnOpenDynLightFileDialogButton(self, event):  # wxGlade: NPMainFrame.<event_handler>
        """load dynamic light program from csv file"""
        # select file to read
        dirname = ''
        dlg     = wx.FileDialog(self, "Choose dynamic light definition file", dirname, "", "CSV files (*.txt;*.csv)|*.txt;*.csv", wx.OPEN)
        fp      = None
        if dlg.ShowModal() == wx.ID_OK:
            filename    = dlg.GetFilename()
            dirname     = dlg.GetDirectory()
            fp          = os.path.join(dirname, filename)
        dlg.Destroy()
        # abort if no file selected
        if not fp:
            return
        
        with open(fp, 'r') as f:
            content = f.readlines()
        # init
        self.dynLight = [[(0,0)]*maxDynLightLen, [(0,0)]*maxDynLightLen, [(0,0)]*maxDynLightLen]
        
        for l in content:
            if not l.startswith("#"):
                item = [long(x) for x in l.split(",")]
                print item
                # if not (item[0] < 0 or item[1] < 0):
                self.dynLight[int(item[0])-1][int(item[1])] = (item[2],item[3])
        if DEBUG:
            print "Parsed dynamic light program from " + fp + ")..."
        self.dyn_light_filepath_label.SetLabel(fp)
    
    def OnOpenUploadDynLightButton(self, event):  # wxGlade: NPMainFrame.<event_handler>
        """sends the dynamic light program to the reactor"""
        if self.dynLight == None:
            print "No dynamic light program loaded!"
            return
        chamber_idx = int(self.dyn_light_ch_select_combo_box.GetValue())
        for i,item in enumerate(self.dynLight[chamber_idx]):
            self.sendMessage("bp",str(chamber_idx) + msgSep + str(i) + msgSep + str(item[0]) + msgSep + str(item[1]) + msgSep)

        # for i in range(0,maxDynLightLen):
        #     self.sendMessage("bp",str(chamber_idx) + msgSep + str(i) + msgSep + str(self.dynLight[chamber_idx][i][0]) + msgSep + str(self.dynLight[chamber_idx][i][1]) + msgSep)
            

    def OnOpenDownloadDynLightButton(self, event):  # wxGlade: NPMainFrame.<event_handler>
        """sends command to reactor to answer with current dynamic light program.
        """
        # TODO: implement parsing the reactor reply
        chamber_idx = str(self.dyn_light_ch_select_combo_box.GetValue())
        self.sendMessage("sbp",chamber_idx)

    def OnShowDynLightClicked(self, event):  # wxGlade: NPMainFrame.<event_handler>
        """plot loaded dynamic light profile"""
        self.dynLightPlotFrame = DynLightPlotFrame(self, wx.ID_ANY, "")
        self.dynLightPlotFrame.dynLight = self.dynLight
        self.dynLightPlotFrame.draw()
        self.dynLightPlotFrame.Show()

    def digestReferenceValues(self, dataSections):
        """parses OD reference values sent from reactor, updates gui"""
        values = dataSections[1].split(",")
        self.referenceVals1 = [[0] * self.numLeds for i in range(self.numChambers)]
        # store ref data
        for i in range(0,self.numChambers):
            offset = i * self.numChambers
            for j in range(0,self.numLeds):
                self.referenceVals1[i][j]   = float(values[j+offset])
        self.dataFrame.ref_values_measured_value.SetLabel(str(datetime.now().strftime('%H/%M/%S/%d/%m/%Y')))
        self.reference_values_measured      = True
        self.updateReactorData()

    def digestReactorModeValues(self, dataSections):
        """parses mode change sent from reactor, updates gui"""
        value = dataSections[1].replace(',','')
        newMode = int(value)
        if DEBUG:
            print "detected reactor mode change to:" + str(newMode)
        self.notebook_1_pane_1.mode_radio_box.SetSelection(newMode)

    def digestSampleValues(self, dataSections):
        """parses sample values sent from reactor, updates gui and writes to log file"""
        if DEBUG:
            print "parsing sample data"
        
        values          = dataSections[1].split(",")            
        
        # store OD data
        self.odVals1    = [[0] * self.numLeds for i in range(0,self.numChambers)]
        for iChamber in range(0,self.numChambers):
            offset = iChamber * self.numLeds
            for i in range(0,self.numLeds):
                self.odVals1[iChamber][i] = float( values[i+offset] )

        # background values for both detectors
        bgValues        = dataSections[2].split(",")
        self.bgVals     = [0] * self.numChambers
        for iChamber in range(0,self.numChambers):
                self.bgVals[iChamber] = float(bgValues[iChamber])

        tempValues      = dataSections[3].split(",")
        self.temp       = [0] * self.numChambers
        for iChamber in range(0,self.numChambers):
                self.temp[iChamber] = float(tempValues[iChamber])

        lightValues             = dataSections[4].split(",")
        self.lightBrightness    = [0] * self.numChambers
        for iChamber in range(0,self.numChambers):
                self.lightBrightness[iChamber] = int(lightValues[iChamber])
                
        lightValues     = dataSections[5].split(",")
        self.minLight   = [0] * self.numChambers
        for iChamber in range(0,self.numChambers):
                self.minLight[iChamber] = int(lightValues[iChamber])
        lightValues     = dataSections[6].split(",")
        self.maxLight   = [0] * self.numChambers
        for iChamber in range(0,self.numChambers):
                self.maxLight[iChamber] = int(lightValues[iChamber])
                
        # other parameters
        otherValues         = dataSections[7].split(",")
        self.sampleRate     = int(otherValues[0])
        self.sampleTime     = otherValues[1]
        self.reactorMode    = int(otherValues[2])
        # self.sampleTime    = datetime.now().strftime('%Y/%m/%d/%H/%M/%S')
        # show in gui
        self.updateReactorData()
        # add data to datastore
        dt = [self.sampleTime] + [self.odVals1[i][j] for i in range(0,self.numChambers) for j in range(0,self.numLeds)] + bgValues + self.temp + self.lightBrightness + [self.reactorMode]
        # check if data store already initialized, otherwise do so
        if(self.dataStore == None):
            print 'Error, data store not initialized...'
        else:
            # save data
            self.dataStore.addSample(dt, self.VARIABLE_NAMES)
        
        # write to log file
        self.logData(dt)
        
        # if activated, refresh OD curve plot
        if not self.odCurveFrame == None:
            self.odCurveFrame.draw_plot()

    def digestLightProfile(self, dataSections):
        """parses light profile values sent from reactor"""
        values = dataSections[1].split(",")
        dl = []
        for i in range(0,len(values)-1,2):
            item = [long(x) for x in values[i:(i+2)]]
            if not (item[0] < 0 or item[1] < 0):
                dl.append(item)
        if len(dl) > 0:
            self.dynLight = dl

    def digestHandshake(self, dataSections):
        """parses Handshake from reactor"""
        values              = dataSections[1].split(",")
        self.numChambers    = int(values[0])
        self.numLeds        = int(values[1])
        refValsMeasured     = values[2]
        
        self.dataStore      = None
        # initalize data arrays
        self.odVals1        = [[0] * self.numLeds] * self.numChambers
        self.referenceVals1 = [[0] * self.numLeds] * self.numChambers
        self.temp           = [0] * self.numChambers
        self.bgVals         = [0] * self.numChambers
        self.lightBrightness = [0] * self.numChambers
        self.minLight       = [0] * self.numChambers
        self.maxLight       = [0] * self.numChambers
        # set GUI labels
        for i in range(0,3):
            for j in range(0,5):
                if j < self.numLeds and i < self.numChambers:
                    label_str   = CHANNEL_NAMES[j] + "(Ch " + str(i) + ")"
                    val_str     = "-"
                else:
                    label_str   = ""
                    val_str     = ""
                self.reference_val_labels[i][j].SetLabel(label_str)
                self.reference_val_data_labels[i][j].SetLabel(val_str)
        for i in range(0,5):
            if i < self.numLeds:
                label_str   = CHANNEL_NAMES[i]
                val_str     = '-'
            else:
                val_str = ''
                label_str = ''
            self.od_data_labels[i].SetLabel(label_str)
            self.od_val_data_labels[i].SetLabel(val_str)
            
        # list available chambers in dynamic light selection box
        self.dyn_light_ch_select_combo_box.Clear()
        # get list of connections
        for i in range(0, self.numChambers):
            # add combo box in main frame
            self.dyn_light_ch_select_combo_box.Append(str(i))
        self.dyn_light_ch_select_combo_box.SetSelection(0)

        # show number of chambers and OD channels in the Gui
        self.dataFrame.num_chambers_value.SetLabel(str(self.numChambers))
        self.dataFrame.num_leds_value.SetLabel(str(self.numLeds))
        
        # indicate if reactor has already reference values
        if len(refValsMeasured):
            self.dataFrame.ref_values_measured_value.SetLabel(refValsMeasured)
            self.reference_values_measured      = True
        
        # initialize the data store: assemble list of variable names
        self.VARIABLE_NAMES = ['Time'] + [cn + '_ch' + str(i) for i in range(0,self.numChambers) for cn in CHANNEL_NAMES[0:self.numLeds] ]
        self.VARIABLE_NAMES = self.VARIABLE_NAMES + ['bg_ch' + str(i) for i in range(0,self.numChambers)]
        self.VARIABLE_NAMES = self.VARIABLE_NAMES + ['temp_ch' + str(i) for i in range(0,self.numChambers)]
        self.VARIABLE_NAMES = self.VARIABLE_NAMES + ["Brightness", "ReactorMode"]
        self.dataStore = DataStore(BUFFER_SIZE, self.VARIABLE_NAMES)
        
        # tell the reactor that the handshake was taken
        self.sendMessage("hi","")

    def logData(self, data):
        """write sample to log file"""
        # check if logging to file is activated, otherwise do nothing...
        if not self.logging_active:
            return
        ls = self.assmebleLogString(str(x) for x in data)
        self.writeToLog(ls)

    def writeToLog(self,value):
        """writes variable to log file"""
        with open(self.label_active_log_file.GetLabel(), 'a') as f:
            f.write(value)

    def assmebleLogString(self, data):
        """combines last sample values into a log string"""
        ls = msgSep.join(data) + '\n'
        return ls

    def updateReactorData(self):
        """updates gui with current sample data"""
        # show data in gui
        for i in range(0,self.numChambers):
            offset = i * self.numChambers
            for j in range(0,self.numLeds):
                self.reference_val_data_labels[i][j].SetLabel(str(self.referenceVals1[i][j]))
        for j in range(0,self.numLeds):
            self.od_val_data_labels[j].SetLabel(str(','.join([str(self.odVals1[i][j]) for i in range(0,self.numChambers)]) ))

        # background values for detector
        self.dataFrame.background_od_label.SetLabel(str(','.join([str(s) for s in self.bgVals])))
        # sample temperature
        self.dataFrame.temp_label.SetLabel(str(','.join([str(s) for s in self.temp])))
        # brightness
        self.dataFrame.bgt_label.SetLabel(str(','.join([str(s) for s in self.lightBrightness]))) 
        # sample time
        self.dataFrame.time_label.SetLabel(str(self.sampleTime))

        self.notebook_1_pane_1.text_ctrl_min_led_bght.SetValue(str(','.join([str(s) for s in self.minLight])))
        self.notebook_1_pane_1.text_ctrl_max_led_bght.SetValue(str(','.join([str(s) for s in self.maxLight])))
        self.notebook_1_pane_1.text_ctrl_sampling_rate.SetValue(str(self.sampleRate))

    def resetReactorData(self):
        "clear previous values from reactor data panel upon disconnect"
        # show data in gui
        for i in range(0,self.numChambers):
            offset = i * self.numChambers
            for j in range(0,self.numLeds):
                self.reference_val_data_labels[i][j].SetLabel("")
        for j in range(0,self.numLeds):
            self.od_val_data_labels[j].SetLabel("")

        # background values for detector
        self.dataFrame.background_od_label.SetLabel("")
        # sample temperature
        self.dataFrame.temp_label.SetLabel("")
        # brightness
        self.dataFrame.bgt_label.SetLabel("") 
        # sample time
        self.dataFrame.time_label.SetLabel("")

        self.notebook_1_pane_1.text_ctrl_min_led_bght.SetValue("")
        self.notebook_1_pane_1.text_ctrl_max_led_bght.SetValue("")
        self.notebook_1_pane_1.text_ctrl_sampling_rate.SetValue("")
        
    def sendMessage(self, param, value):
        """commits message to the reactor, first the parameter name then the value(s)"""
        if(not self.serial.isOpen()):
            if DEBUG:
                print "Not connected!"
            return
        msg = param + msgSep + value + msgTerm
        self.serial.write(msg)
        if DEBUG:
            print "sending message: " + msg

    def list_connections(self):
        """provides combo box with list of available serial connections"""
        # remove all connections from combo box
        self.serial_connection_combo_box.Clear()
        # get list of connections
        av_cons = list_ports.comports()
        for path,name,hw in av_cons:
            # add combo box in main frame
            self.serial_connection_combo_box.Append(path)

    def OnActivateLoggingButtonClicked(self, event):  # wxGlade: NPMainFrame.<event_handler>
        """logging only permitted with connected reactor and data store created.
        on activation the headerline with parameter names is added to the log file"""
        if not self.serial.isOpen() or self.dataStore == None:
            msgbox = wx.MessageBox('Need to connect reactor and start sampling before logging can be activated!', 
                                   'Warning', wx.ICON_EXCLAMATION | wx.STAY_ON_TOP)
            # deactivate logging again
            self.logging_active_button.SetLabel("Activate Logging")
            self.logging_active = False
            self.logging_active_button.SetValue(False)
            return
        if self.logging_active:
            self.logging_active_button.SetLabel("Activate Logging")
            self.logging_active = False
            self.logging_active_button.SetValue(False)
        else:
            self.logging_active_button.SetLabel("Deactivate Logging")
            self.logging_active_button.SetValue(False)
            logHeader = '#' + ','.join(self.VARIABLE_NAMES)  + "\n"
            self.logging_active = True
            self.writeToLog(logHeader)

    def OnDownloadReactorLogButton(self, event):  # wxGlade: NPMainFrame.<event_handler>
        """ request from reactor to send all data from current log
        """
        if not self.serial.isOpen() or self.dataStore == None:
            msgbox = wx.MessageBox('Not connect to reactor!', 
                               'Warning', wx.ICON_EXCLAMATION | wx.STAY_ON_TOP)
            return
        if not self.logging_active:
            msgbox = wx.MessageBox('Logging must be activated for download!', 
                               'Warning', wx.ICON_EXCLAMATION | wx.STAY_ON_TOP)
            return
        self.sendMessage("log","")

# end of class NPMainFrame

class DataStore(object):
    """ A silly class buffering the data history for
        display in the plot frame.
    """
    def __init__(self, l, vn):
        """init data structures"""
        # l - number of samples of historical data to plot
        # vn - names of variables to store        
        self.data = {}
        for varNm in vn:
            self.data[varNm] = deque([float("nan")])
        self.plotL = l
        
    def addSample(self, data, vn):
        """stores new data row"""
        # adds data to the according queues, in the order of the provided names
        for i,varNm in enumerate(vn):
            self.data[varNm].append(data[i])
            # if DEBUG:
            #     print 'adding to "' + varNm + '"value: ' + str(data[i]) + '\n'
            if len(self.data[varNm]) > self.plotL:
                self.data[varNm].popleft()

    def getData(self, varName):
        """provides the data series with provided name"""
        return self.data[varName]
        
    def clear(self):
        """reset data structure"""
        vn = self.data.keys()
        self.data = {}
        for varNm in vn:
            self.data[varNm] = deque([float("nan")])
        
class SerialRxEvent(wx.PyCommandEvent):
    """Event used to transfer the data read from the serial connection
    to the interface thread
    """
    eventType = SERIALRX
    def __init__(self, windowID, data):
        wx.PyCommandEvent.__init__(self, self.eventType, windowID)
        self.data = data

    def Clone(self):
        self.__class__(self.GetId(), self.data)
